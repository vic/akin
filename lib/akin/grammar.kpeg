# -*- ruby -*-
#
# This is a KPEG grammar for Akin.
# If you want to compile it into grammar.rb, you must use vic/kpeg.
# 

%% name = Akin::Grammar
%% { include Akin::Parser }

nl = "\n" | "\r\n"
sp = " " | "\t" | "\\" nl

p = &. ~current_position

sheebang = "#!" /.*?$/

w = (sp | sheebang | nl)*
o = sp* (sheebang | nl)
t = ";" | sheebang | nl
n = t | sp | "."
- = n*

brace = < . . > &{ brace(text) } { brace(text) }
      | < . > &{ brace(text) } { brace(text) }

left_brace = <brace:b> &{ text == b.first} { b }
right_brace(l) = <brace:b> &{ text == l.last } { l }
  
literal = float | fixnum | str | regexp

symbol(h) = p:p ":" value(h):v ~n(p, :symbol, v)

regexp = p:p quoted(:text, & "/"):b ~n(p, :regexp, text_node(p, b))

float = p:p sign:s dec:n "." dec:f ~n(p, :float, (s+n+"."+f).to_f)

fixnum = p:p (hexadec | binary | octal | decimal):n ~n(p, :fixnum, n)

digits(d) = < d+ ("_" d+)* > { text.gsub('_', '') }

sign = "+" {"+"} | "-" { "-"} | {"+"}

dec = digits(&/[0-9]/):d {d}
oct = "0" /[oO]/? digits(&/[0-7]/):d {d}
hex = "0" /[xX]/ digits(&/[0-9a-fA-F]/):d {d}
bin = "0" /[bB]/ digits(&/[0-1]/):d {d}

hexadec = sign:s hex:d {(s+d).to_i(16)}
binary = sign:s bin:d {(s+d).to_i(2)}
octal = sign:s oct:d {(s+d).to_i(8)}
decimal = sign:s dec:d {(s+d).to_i(10)}

str = (mstr | sstr | qstr)

qstr = p:p "'" <( "\\'" | !&"'" .)*> "'" ~n(p, :text, text)

sstr = p:p quoted(:text, & "\""):b ~text_node(p, b)

quoted(t,q) = q quoted_inner(t,q)*:b q {b}

quoted_inner(t,q) = p:p "#{" - block(h)?:b - "}" {b}
                  | p:p < ("\\" q | "\\#" | &!((q | "#{")) .)+ > ~n(p, t, text)

mstr = p:p "\"\"\"" mstr_inner*:b "\"\"\"" ~text_node(p, b)

mstr_inner = p:p "#{" - block(h)?:b - "}" {b}
          | p:p < ("\\\"\"\"" | 
             !&("\"\"\"" | "#{") . | . &("\"\"\""))+ > ~n(p, :text, text)

opchr = /[\~\!@\#\$%\^\&\|\?\<\>*\/+-]/
oper = < opchr (opchr | /[=]/)* > {text}

operator = p:p oper:o ~n(p, :oper, o)

name = p:p <(&(!(sp|nl|brace|opchr|":"|";"|","|".")) .)+> ~n(p, :name, text)

keyword = < (!&(n | ":" | brace) .)+ > ":" &{text.size > 0} !&(":"|";"|".") {text}
keyargs = < (!&(n | ":" | brace) .)+ > args:a ":" {[text, a]}
keypart = keyword | keyargs

value(h) = msg(h)
         | value(h):v args:a ~n(v.pos, :act, v, a.name, *a.args)
         | args:a ~n(a.pos, :act, nil, a.name, *a.args)
         | literal | operator | name | symbol(h)

comma_left(h) = block(h):a w "," {a}

comma(h) = comma_left(h):a w comma(h):b { b.unshift a ; b }
         | comma_left(h):a w block(h):b { [a,b] }
         | comma_left(h):a &(sp* ("."|","|t|brace)) {[a]}
  
tuple(h) = comma(h):c ~n(p, :tuple, *c)

cons_left(h) = expr(h):a sp* "::" !&(":"|";"|".")  {a}

cons(h) = cons_left(h):a - chain_val(h):b ~n(p, :cons, a, b)

args = p:p left_brace:l - (comma(h) | block(h) | {[]}):a - right_brace(l)
       ~n(p, l.join, *Array(a))

msg(h) = msg(h):a sp* (&("::") | ":" &(":"|";"|".")) {a}
       | part(h):a w msg(h | a.pos):m ~n(a.pos, :msg, a, *m.args)
       | part(h):a ~n(a.pos, :msg, a)

part(h) = part(h):p o w block(h | p.pos):e { p.args.push *Array(e) ; p }
        | part(h):p part_head(h | p.pos):e { p.args.push *Array(e) ; p }
        | p:p keyargs:k ~n(p, k.first, k.last.name, *k.last.args)
        | p:p keyword:k ~n(p, k, nil)

part_head(h) = sp+ !&keypart (ph_comma(h) | expr(h) | {[]})

ph_comma(h) = expr(h):a w "," - ph_comma(h):b { b.unshift a ; b }
            | expr(h):a w "," - expr(h):b { [a,b] }

expr(h) = value(h):e &{ e.pos.column > h.column } {e}

chain(h) = chain(h):a w "." - chain(h):b ~n(a.pos, :chain, a, b)
         | operator:a !&brace o w chain(h):b
           ~n(a.pos, :chain, a, *Array(b.name == :chain && b.args || b))
         | chain_cont(h)
         | chain_val(h):a sp* chain(a.pos):b
           ~n(a.pos, :chain, a, *Array(b.name == :chain && b.args || b))
         | chain_val(h)

chain_cont(h) = chain_val(h):a {(h | a.pos || h()).incr}:i sp*
                (comma(h) | (nl|sheebang) - block(i)):c
              {
                if a.name == :act
                   a.args.push *Array(c); a
                else
                   n(a.pos, :act, a, nil, *Array(c))
                end
              }

chain_val(h) = cons(h) | expr(h)

block(h) = chain(h):a sp* t - block(h):b
           ~n(a.pos, :block, a, *Array(b.name == :block && b.args || b))
         | chain(h)

root = - block(h)?:b - eof {b}
unit = - chain(h):c {c}
eof = !.
