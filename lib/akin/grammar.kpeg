# -*- ruby -*-
#
# This is a KPEG grammar for Akin.
# If you want to compile it into grammar.rb, you must use vic/kpeg.
# 

%% name = Akin::Grammar
%% { include Akin::Parser }

nl = "\n" | "\r\n"
sp = " " | "\t" | "\\" nl

p = &. ~current_position

sheebang = "#!" /.*?$/

w = (sp | sheebang | nl)*
o = sp* (sheebang | nl)
t = ";" | sheebang | nl
n = t | sp | "."
- = n*

brace = < . . > &{ brace(text) } { brace(text) }
      | < . > &{ brace(text) } { brace(text) }

left_brace = <brace:b> &{ text == b.first} { b }
right_brace(l) = <brace:b> &{ text == l.last } { l }
  
literal = float | fixnum | str | regexp

symbol(h) = p:p ":" !&":" value(h.keymsg(true)):v ~n(p, :symbol, v)

regexp = p:p quoted(:text, & "/"):b ~n(p, :regexp, text_node(p, b))

float = p:p sign:s dec:n "." dec:f ~n(p, :float, (s+n+"."+f).to_f)

fixnum = p:p (hexadec | binary | octal | decimal):n ~n(p, :fixnum, n)

digits(d) = < d+ ("_" d+)* > { text.gsub('_', '') }

sign = "+" {"+"} | "-" { "-"} | {"+"}

dec = digits(&/[0-9]/):d {d}
oct = "0" /[oO]/? digits(&/[0-7]/):d {d}
hex = "0" /[xX]/ digits(&/[0-9a-fA-F]/):d {d}
bin = "0" /[bB]/ digits(&/[0-1]/):d {d}

hexadec = sign:s hex:d {(s+d).to_i(16)}
binary = sign:s bin:d {(s+d).to_i(2)}
octal = sign:s oct:d {(s+d).to_i(8)}
decimal = sign:s dec:d {(s+d).to_i(10)}

str = (mstr | sstr | qstr)

qstr = p:p "'" <( "\\" escape |  "\\'" | !&"'" .)*> "'" ~n(p, :text, text)

sstr = p:p quoted(:text, & "\""):b ~text_node(p, b)

quoted(t,q) = q quoted_inner(t,q)*:b q {b}

quoted_inner(t,q) = p:p "#{" - block(ctx)?:b - "}" {b}
                  | p:p < ("\\" escape | ("\\" q | "\\#" | &!((q | "#{")) .))+ > 
                    ~n(p, t, text)

mstr = p:p "\"\"\"" mstr_inner*:b "\"\"\"" ~text_node(p, b)

mstr_inner = p:p "#{" - block(h)?:b - "}" {b}
           | p:p < ( "\\" escape | ("\\\"\"\"" | 
                   !&("\"\"\"" | "#{") . | . &("\"\"\"")) )+ >
            ~n(p, :text, text)

opchr = /[\~\!@\#\$%\^\&\|\?\<\>*\/+=-]/
oper = < opchr (opchr)* > {text}

operator = p:p oper:o ~n(p, :oper, o)

name = p:p <(&(!(sp|nl|brace|opchr|":"|";"|","|".")) .)+> ~n(p, :name, text)

keyword = < (!&(n | ":" | brace) .)+ > ":" !&(":"|";"|".") {text}
keyargs = < (!&(n | ":" | brace) .)+ > args:a ":" {[text, a]}
keypart = keyword | keyargs

value(h) = msg(h)
         | value(h):v args:a ~n(v.pos, :act, v, a.name, *a.args)
         | args:a ~n(a.pos, :act, nil, a.name, *a.args)
         | literal | symbol(h)
         | &{h.keymsg?} name | &{!h.keymsg?} name &!(":")
         | &{h.keymsg?} operator | &{!h.keymsg?} operator &!(":")

comma_left(h) = block(h):a w "," {a}

comma(h) = comma_left(h):a w comma(h):b { b.unshift a ; b }
         | comma_left(h):a w block(h):b { [a,b] }
         | comma_left(h):a &(sp* ("."|","|t|brace)) {[a]}
  
tuple(h) = comma(h):c ~n(p, :tuple, *c)

cons_left(h) = expr(h):a sp* "::" !&(":"|";"|".")  {a}

cons(h) = cons_left(h):a - chain_val(h):b ~n(p, :cons, a, b)

args = p:p left_brace:l - (comma(ctx) | block(ctx) | {[]}):a - right_brace(l)
       ~n(p, l.join, *Array(a))

msg(h) = &{h.keymsg?} kmsg(h) | emsg(h)

kmsg(h) = kmsg(h):a sp* (&("::") | ":" &(";"|".")) {a}
        | part(h):a w kmsg(h.at?(a.pos)):m ~n(a.pos, :msg, a, *m.args)
        | part(h):a ~n(a.pos, :msg, a)

part(h) = part(h):p o w block(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
        | part(h):p sp+ part_head(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
        | p:p keyargs:k ~n(p, k.first, k.last.name, *k.last.args)
        | p:p keyword:k ~n(p, k, nil)

part_head(h) = !&keypart (ph_comma(h.keymsg(false)) | chain(h.keymsg(false)) | {[]})

ph_comma(h) = chain(h):a w "," - ph_comma(h):b { b.unshift a ; b }
            | chain(h):a w "," - chain(h):b { [a,b] }

emsg(h) = emsg(h):a sp* (&("::") | ":" &(";"|".")) {a}
        | (epart(h) | spart(h)):a ~n(a.pos, :msg, a)

epart(h) = epart(h):p o w block(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
         | epart(h):p sp+ epart_head(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
         | args:a ":" !&":" ~n(a.pos, nil, a.name, *a.args)

spart(h) = spart(h):p o w block(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
         | spart(h):p sp* epart_head(h.at?(p.pos)):e { p.args.push *Array(e) ; p }
         | p:p ":" (sp|nl|sheebang) ~n(p, nil, nil)

epart_head(h) = ph_comma(h) | chain(h.keymsg(false)) | {[]}

expr(h) = value(h):e &{ e.pos.column > h.pos.column } {e}

chain(h) = chain(h):a w "." - chain(h):b ~chain_cont(a, b)
         | operator:a !&brace o w chain(h):b
           ~n(a.pos, :chain, a, *Array(b.name == :chain && b.args || b))
         | chain_val(h):a sp* chain(h.at(a.pos)):b ~chain_cont(a, b)
         | chain_val(h)

chain_val(h) = cons(h) | expr(h)

block(h) = chain(h):a sp* t - block(h):b
           ~n(a.pos, :block, a, *Array(b.name == :block && b.args || b))
         | chain(h)

escape = number_escapes | escapes
escapes = "n" { "\n" }
                | "s" { " " }
                | "r" { "\r" }
                | "t" { "\t" }
                | "v" { "\v" }
                | "f" { "\f" }
                | "b" { "\b" }
                | "a" { "\a" }
                | "e" { "\e" }
                | "\\" { "\\" }
                | "\"" { "\"" }
                | "BS" { "\b" }
                | "HT" { "\t" }
                | "LF" { "\n" }
                | "VT" { "\v" }
                | "FF" { "\f" }
                | "CR" { "\r" }
                | "SO" { "\016" }
                | "SI" { "\017" }
                | "EM" { "\031" }
                | "FS" { "\034" }
                | "GS" { "\035" }
                | "RS" { "\036" }
                | "US" { "\037" }
                | "SP" { " " }
                | "NUL" { "\000" }
                | "SOH" { "\001" }
                | "STX" { "\002" }
                | "ETX" { "\003" }
                | "EOT" { "\004" }
                | "ENQ" { "\005" }
                | "ACK" { "\006" }
                | "BEL" { "\a" }
                | "DLE" { "\020" }
                | "DC1" { "\021" }
                | "DC2" { "\022" }
                | "DC3" { "\023" }
                | "DC4" { "\024" }
                | "NAK" { "\025" }
                | "SYN" { "\026" }
                | "ETB" { "\027" }
                | "CAN" { "\030" }
                | "SUB" { "\032" }
                | "ESC" { "\e" }
                | "DEL" { "\177" }
                | < . > { "\\" + text }

number_escapes = /[xX]/ < /[0-9a-fA-F]{1,5}/ > { [text.to_i(16)].pack("U") }
               | < /\d{1,6}/ > { [text.to_i].pack("U") }
               | /[oO]/ < /[0-7]{1,7}/ > { [text.to_i(16)].pack("U") }
               | /[uU]/ < /[0-9a-fA-F]{4}/ > { [text.to_i(16)].pack("U") }


root = - block(ctx)?:b - eof {b}
unit = - chain(ctx):c {c}
eof = !.
